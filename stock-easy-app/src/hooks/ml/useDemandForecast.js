/**
 * Hook React pour les pr√©visions de demande ML
 * @module hooks/ml/useDemandForecast
 */

import { useState, useEffect, useRef } from 'react';
import { DemandForecastModel } from '../../services/ml/demandForecastModel';
import { collectSalesHistory } from '../../services/ml/dataCollector';

/**
 * Hook pour g√©rer les pr√©visions de demande avec ML
 * @param {Array} products - Liste des produits
 * @returns {Object} √âtat et fonctions du mod√®le ML
 */
export function useDemandForecast(products) {
  const [forecasts, setForecasts] = useState({});
  const [isTraining, setIsTraining] = useState(false);
  const [isReady, setIsReady] = useState(false);
  const [error, setError] = useState(null);
  const [trainingProgress, setTrainingProgress] = useState(0);
  
  const modelRef = useRef(null);

  /**
   * Initialise le mod√®le (charge ou entra√Æne) - une seule fois
   */
  useEffect(() => {
    let mounted = true;
    
    const initModel = async () => {
      try {
        console.log('ü§ñ Initialisation du mod√®le ML...');
        
        // Cr√©er l'instance
        const model = new DemandForecastModel();
        modelRef.current = model;
        
        // Essayer de charger un mod√®le existant
        try {
          const loaded = await model.load();
          
          if (!mounted) return;
          
          if (loaded && products && products.length > 0) {
            console.log('‚úÖ Mod√®le charg√© depuis le cache');
            setIsReady(true);
            
            // G√©n√©rer les pr√©visions avec les produits
            await generateForecasts(model, products);
          } else {
            console.log('‚ÑπÔ∏è Pas de mod√®le en cache');
            console.log('üí° Cliquez sur "R√©entra√Æner" pour g√©n√©rer des pr√©visions');
          }
        } catch (loadError) {
          console.log('‚ÑπÔ∏è Pas de mod√®le sauvegard√© trouv√©');
        }
        
      } catch (err) {
        if (mounted) {
          console.error('‚ùå Erreur lors de l\'initialisation:', err);
          setError(err.message);
        }
      }
    };

    initModel();

    // Cleanup
    return () => {
      mounted = false;
      if (modelRef.current) {
        modelRef.current.dispose();
        modelRef.current = null;
      }
    };
  }, []); // Une seule fois au montage

  /**
   * Entra√Æne le mod√®le
   */
  const trainModel = async () => {
    if (isTraining) {
      console.log('‚ö†Ô∏è Entra√Ænement d√©j√† en cours');
      return;
    }

    try {
      setIsTraining(true);
      setError(null);
      setTrainingProgress(0);
      
      console.log('üìä Collecte des donn√©es d\'entra√Ænement...');
      
      // Collecter l'historique
      const salesHistory = await collectSalesHistory();
      
      if (salesHistory.length < 50) {
        throw new Error('Pas assez de donn√©es pour entra√Æner (minimum 50 enregistrements)');
      }
      
      setTrainingProgress(20);
      console.log(`‚úÖ ${salesHistory.length} enregistrements collect√©s`);
      
      // Entra√Æner
      console.log('üöÄ Entra√Ænement du mod√®le...');
      const model = modelRef.current || new DemandForecastModel();
      modelRef.current = model;
      
      await model.train(salesHistory, {
        epochs: 100,
        batchSize: 32,
        validationSplit: 0.2,
        verbose: 0
      });
      
      setTrainingProgress(80);
      
      // Sauvegarder
      console.log('üíæ Sauvegarde du mod√®le...');
      await model.save();
      
      setTrainingProgress(90);
      
      // G√©n√©rer les pr√©visions
      await generateForecasts(model, products);
      
      setTrainingProgress(100);
      setIsReady(true);
      console.log('‚úÖ Entra√Ænement termin√© avec succ√®s!');
      
    } catch (err) {
      console.error('‚ùå Erreur lors de l\'entra√Ænement:', err);
      setError(err.message);
    } finally {
      setIsTraining(false);
    }
  };

  /**
   * G√©n√®re les pr√©visions pour tous les produits
   */
  const generateForecasts = async (model, productList) => {
    if (!model || !model.isReady()) {
      console.log('‚ö†Ô∏è Mod√®le pas pr√™t pour les pr√©visions');
      return;
    }

    if (!productList || productList.length === 0) {
      console.log('‚ö†Ô∏è Aucun produit disponible pour les pr√©visions');
      return;
    }

    try {
      console.log('üîÆ G√©n√©ration des pr√©visions...');
      
      const newForecasts = {};
      const today = new Date();
      
      for (const product of productList) {
        // Pr√©dire les 7 prochains jours
        const next7Days = [];
        
        for (let i = 0; i < 7; i++) {
          const futureDate = new Date(today);
          futureDate.setDate(today.getDate() + i);
          
          const prediction = await model.predict({
            dayOfWeek: futureDate.getDay(),
            month: futureDate.getMonth() + 1,
            isWeekend: [0, 6].includes(futureDate.getDay()),
            isHoliday: false, // TODO: int√©grer API jours f√©ri√©s
            price: product.sellPrice || 0,
            avgSales: product.salesPerDay || 0
          });
          
          next7Days.push(prediction);
        }
        
        // Calculer les m√©triques
        const averagePredicted = next7Days.reduce((a, b) => a + b, 0) / 7;
        const trend = next7Days[6] > next7Days[0] ? 'up' : 'down';
        const confidence = calculateConfidence(next7Days, product.salesPerDay);
        
        newForecasts[product.sku] = {
          next7Days,
          averagePredicted,
          trend,
          confidence,
          recommendedOrder: calculateRecommendedOrder(
            averagePredicted,
            product.stock,
            product.leadTimeDays
          )
        };
      }
      
      setForecasts(newForecasts);
      console.log(`‚úÖ Pr√©visions g√©n√©r√©es pour ${Object.keys(newForecasts).length} produits`);
      
    } catch (err) {
      console.error('‚ùå Erreur lors de la g√©n√©ration des pr√©visions:', err);
      setError(err.message);
    }
  };

  /**
   * Calcule un score de confiance
   */
  const calculateConfidence = (predictions, actualAvg) => {
    const predictedAvg = predictions.reduce((a, b) => a + b, 0) / predictions.length;
    const variance = predictions.reduce((sum, val) => 
      sum + Math.pow(val - predictedAvg, 2), 0) / predictions.length;
    
    // Confiance inversement proportionnelle √† la variance
    const stdDev = Math.sqrt(variance);
    const coefficient = stdDev / (predictedAvg + 1);
    
    // Score de 0 √† 100
    return Math.max(0, Math.min(100, 100 - (coefficient * 100)));
  };

  /**
   * Calcule la quantit√© recommand√©e √† commander
   */
  const calculateRecommendedOrder = (predictedDailySales, currentStock, leadTimeDays) => {
    const demandDuringLeadTime = predictedDailySales * leadTimeDays;
    const securityStock = demandDuringLeadTime * 0.2; // 20% de s√©curit√©
    const reorderPoint = demandDuringLeadTime + securityStock;
    
    return Math.max(0, Math.round(reorderPoint - currentStock));
  };

  /**
   * R√©entra√Æne le mod√®le manuellement
   */
  const retrain = async () => {
    console.log('üîÑ R√©entra√Ænement manuel d√©clench√©');
    await trainModel();
  };

  /**
   * Obtient la pr√©vision pour un produit sp√©cifique
   */
  const getForecastForProduct = (sku) => {
    return forecasts[sku] || null;
  };

  return {
    forecasts,
    isTraining,
    isReady,
    error,
    trainingProgress,
    retrain,
    getForecastForProduct
  };
}

